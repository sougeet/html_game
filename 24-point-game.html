
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2597042766299857"
     crossorigin="anonymous"></script>
    <script defer src="https://umami.jerryz.com.cn/script.js" data-website-id="319efe93-a9d5-4f43-bfad-7bb27b46f56c"></script>
    <title>24ç‚¹æ¸¸æˆ</title>
    <style>
        /* Material You è®¾è®¡ç³»ç»Ÿé¢œè‰² */
        :root {
            /* ä¸»è‰² */
            --md-sys-color-primary: #006493;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #c9e6ff;
            --md-sys-color-on-primary-container: #001e30;

            /* æ¬¡è¦è‰² - è°ƒæ•´ä¸ºè“ç°è‰²ç³» */
            --md-sys-color-secondary: #4A6572;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #D0E4FF;
            --md-sys-color-on-secondary-container: #0F1B24;

            /* ä¸‰çº§è‰² - è°ƒæ•´ä¸ºè“é’è‰²ç³» */
            --md-sys-color-tertiary: #0088A3;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #d5f4ff;
            --md-sys-color-on-tertiary-container: #002A35;

            /* é”™è¯¯è‰² - ä¿æŒåŸæ · */
            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #F9DEDC;
            --md-sys-color-on-error-container: #370B1E;

            /* ä¸­æ€§è‰² - è°ƒæ•´ä¸ºå¸¦è“è‰²è°ƒçš„ä¸­æ€§è‰² */
            --md-sys-color-background: #FFFBFE;
            --md-sys-color-on-background: #1A1C1E;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1A1C1E;
            --md-sys-color-surface-variant: #DDE3EA;
            --md-sys-color-on-surface-variant: #41484D;
            --md-sys-color-outline: #72787E;
            --md-sys-color-outline-variant: #C0C6CC;

            /* ä¸­æ€§å˜ä½“ - è“è‰²ç³»æ¸å˜ */
            --md-sys-color-surface-1: #ECF4FF;
            --md-sys-color-surface-2: #E0EDFA;
            --md-sys-color-surface-3: #D3E6F5;
            --md-sys-color-surface-4: #C7DFEF;
            --md-sys-color-surface-5: #BBD8EA;

            /* æè´¨é«˜åº¦ - ä¿æŒä¸å˜ */
            --md-sys-elevation-level1: 0 1px 2px rgba(0, 0, 0, 0.3), 0 1px 3px 1px rgba(0, 0, 0, 0.15);
            --md-sys-elevation-level2: 0 1px 2px rgba(0, 0, 0, 0.3), 0 2px 6px 2px rgba(0, 0, 0, 0.15);
            --md-sys-elevation-level3: 0 4px 8px 3px rgba(0, 0, 0, 0.15), 0 1px 3px rgba(0, 0, 0, 0.3);
            --md-sys-elevation-level4: 0 6px 10px 4px rgba(0, 0, 0, 0.15), 0 2px 3px rgba(0, 0, 0, 0.3);
            --md-sys-elevation-level5: 0 8px 12px 6px rgba(0, 0, 0, 0.15), 0 4px 4px rgba(0, 0, 0, 0.3);

            /* åœ†è§’ - ä¿æŒä¸å˜ */
            --md-sys-shape-corner-extra-small: 4px;
            --md-sys-shape-corner-small: 8px;
            --md-sys-shape-corner-medium: 12px;
            --md-sys-shape-corner-large: 16px;
            --md-sys-shape-corner-extra-large: 28px;

            /* è‡ªå®šä¹‰æ¸¸æˆé¢œè‰² - è°ƒæ•´ä¸ºè“é’è‰²è°ƒ */
            --md-sys-color-success: #00839B;
            --md-sys-color-on-success: #FFFFFF;
            --md-sys-color-success-container: #B2EDFF;
            --md-sys-color-on-success-container: #001F26;
        }

        /* é¡µé¢åŸºç¡€æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', 'Noto Sans SC', sans-serif;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        /* æ ‡é¢˜åŒºåŸŸ */
        header {
            text-align: center;
            margin-bottom: 24px;
            padding: 16px;
        }

        h1 {
            color: var(--md-sys-color-primary);
            font-size: 2.5rem;
            font-weight: 400;
            letter-spacing: 0;
            margin-bottom: 8px;
        }

        .game-description {
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.875rem;
            font-weight: 400;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        /* å¡ç‰‡å®¹å™¨ */
        .md-card {
            background-color: var(--md-sys-color-surface);
            border-radius: var(--md-sys-shape-corner-medium);
            box-shadow: var(--md-sys-elevation-level1);
            overflow: hidden;
            margin-bottom: 16px;
            padding: 16px;
        }

        .md-card-title {
            color: var(--md-sys-color-on-surface);
            font-size: 1.125rem;
            font-weight: 500;
            margin-bottom: 16px;
        }

        /* æ¸¸æˆå¡ç‰‡ */
        .number-card {
            width: 80px;
            height: 112px;
            border-radius: var(--md-sys-shape-corner-medium);
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 500;
            cursor: pointer;
            box-shadow: var(--md-sys-elevation-level1);
            position: relative;
            overflow: hidden;
            user-select: none;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .number-card::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom right, rgba(255, 255, 255, 0.2), transparent);
            pointer-events: none;
        }

        .number-card:hover {
            box-shadow: var(--md-sys-elevation-level2);
            transform: translateY(-2px);
        }

        .number-card.used {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: var(--md-sys-color-outline-variant);
            color: var(--md-sys-color-outline);
            box-shadow: none;
            transform: scale(0.95);
        }

        .number-card.selected {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            box-shadow: var(--md-sys-elevation-level2);
            transform: scale(1.05);
            border: 2px solid var(--md-sys-color-primary);
        }

        .number-card.available {
            border: 2px dashed var(--md-sys-color-tertiary);
        }

        .number-card.result-card {
            background-color: var(--md-sys-color-tertiary-container);
            color: var(--md-sys-color-on-tertiary-container);
        }

        /* æ¸¸æˆåŒºåŸŸ */
        .cards-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 16px;
            margin-bottom: 24px;
        }

        /* æ¸¸æˆçŠ¶æ€ */
        .game-status {
            background-color: var(--md-sys-color-surface-1);
            padding: 12px 16px;
            border-radius: var(--md-sys-shape-corner-large);
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-status-text {
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
        }

        .game-status.success {
            background-color: var(--md-sys-color-success-container);
        }

        .game-status.success .game-status-text {
            color: var(--md-sys-color-on-success-container);
        }

        /* æ“ä½œæŒ‰é’® */
        .operations {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .operation {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--md-sys-elevation-level1);
        }

        .operation:hover {
            background-color: var(--md-sys-color-secondary);
            color: var(--md-sys-color-on-secondary);
            box-shadow: var(--md-sys-elevation-level2);
        }

        .operation:disabled {
            background-color: var(--md-sys-color-outline-variant);
            color: var(--md-sys-color-outline);
            cursor: not-allowed;
            box-shadow: none;
        }

        /* æ“ä½œæ­¥éª¤ */
        .calculation-steps {
            background-color: var(--md-sys-color-surface-2);
            border-radius: var(--md-sys-shape-corner-medium);
            padding: 16px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }

        .calculation-steps::-webkit-scrollbar {
            width: 8px;
        }

        .calculation-steps::-webkit-scrollbar-track {
            background: var(--md-sys-color-surface-variant);
            border-radius: 4px;
        }

        .calculation-steps::-webkit-scrollbar-thumb {
            background-color: var(--md-sys-color-outline);
            border-radius: 4px;
        }

        .step {
            padding: 12px;
            background-color: var(--md-sys-color-surface);
            border-radius: var(--md-sys-shape-corner-small);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--md-sys-elevation-level1);
        }

        .step:last-child {
            margin-bottom: 0;
        }

        .step-text {
            font-weight: 500;
        }

        .step-status {
            font-size: 0.875rem;
            color: var(--md-sys-color-on-surface-variant);
            padding: 4px 8px;
            border-radius: var(--md-sys-shape-corner-extra-small);
            background-color: var(--md-sys-color-surface-variant);
        }

        /* æç¤ºåŒºåŸŸ */
        .hint-container {
            background-color: var(--md-sys-color-tertiary-container);
            border-radius: var(--md-sys-shape-corner-medium);
            padding: 16px;
            margin-bottom: 16px;
            display: none;
        }

        .hint-title {
            color: var(--md-sys-color-on-tertiary-container);
            font-weight: 500;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }

        .hint-title::before {
            content: "ğŸ’¡";
            margin-right: 8px;
        }

        .hint-step {
            background-color: rgba(255, 255, 255, 0.5);
            padding: 8px 12px;
            border-radius: var(--md-sys-shape-corner-small);
            margin-bottom: 8px;
            font-weight: 500;
        }

        /* æŒ‰é’® */
        .md-button {
            height: 40px;
            padding: 0 24px;
            border: none;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
            letter-spacing: 0.1px;
            text-transform: uppercase;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .md-button::after {
            content: "";
            position: absolute;
            inset: 0;
            background-color: transparent;
            transition: background-color 0.2s;
        }

        .md-button:hover::after {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .md-button-filled {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            box-shadow: var(--md-sys-elevation-level1);
        }

        .md-button-filled:hover {
            box-shadow: var(--md-sys-elevation-level2);
        }

        .md-button-tonal {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
        }

        .md-button-outlined {
            background-color: transparent;
            color: var(--md-sys-color-primary);
            border: 1px solid var(--md-sys-color-outline);
        }

        .md-button-outlined:hover::after {
            background-color: rgba(103, 80, 164, 0.08);
        }

        .md-button-text {
            background-color: transparent;
            color: var(--md-sys-color-primary);
        }

        .md-button-success {
            background-color: var(--md-sys-color-success);
            color: var(--md-sys-color-on-success);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        /* ç»Ÿè®¡åŒºåŸŸ */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-item {
            background-color: var(--md-sys-color-surface-1);
            border-radius: var(--md-sys-shape-corner-medium);
            padding: 16px;
            text-align: center;
            box-shadow: var(--md-sys-elevation-level1);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 500;
            color: var(--md-sys-color-primary);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        /* ç­‰çº§æŒ‡ç¤ºå™¨ */
        .level-indicator {
            margin-bottom: 24px;
            background-color: var(--md-sys-color-surface-1);
            border-radius: var(--md-sys-shape-corner-medium);
            padding: 16px;
            box-shadow: var(--md-sys-elevation-level1);
        }

        .level-name {
            font-size: 1.25rem;
            color: var(--md-sys-color-primary);
            text-align: center;
            margin-bottom: 16px;
            font-weight: 500;
        }

        .level-bar {
            height: 8px;
            background-color: var(--md-sys-color-outline-variant);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .level-progress {
            height: 100%;
            background-color: var(--md-sys-color-primary);
            border-radius: 4px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .level-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        /* å†å²è®°å½• */
        .history-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 8px;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-result {
            padding: 4px 8px;
            border-radius: var(--md-sys-shape-corner-extra-small);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .history-success {
            background-color: var(--md-sys-color-success-container);
            color: var(--md-sys-color-on-success-container);
        }

        .history-fail {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }

        /* FABæŒ‰é’® */
        .fab {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: var(--md-sys-color-tertiary);
            color: var(--md-sys-color-on-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: var(--md-sys-elevation-level3);
            cursor: pointer;
            z-index: 10;
            border: none;
        }

        .fab:hover {
            box-shadow: var(--md-sys-elevation-level4);
        }

        .ribbon-shape {
            transform-style: preserve-3d;
            transform: skew(10deg, 10deg);
            transform-origin: center;
        }

        /* æç¤ºæ¶ˆæ¯ */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 0.875rem;
            z-index: 1000;
            box-shadow: var(--md-sys-elevation-level2);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* æˆåŠŸåŠ¨ç”» */
        .confetti {
            position: fixed;
            width: 10px;
            height: 20px;
            background-color: #f0f;
            animation: fall 3s linear forwards;
            /* æ”¹ä¸ºlinearåŠ¨ç”» */
            z-index: 1000;
            border-radius: 2px;
        }

        @keyframes fall {
            0% {
                transform: translateY(-10vh) rotate(0deg);
            }

            100% {
                transform: translateY(120vh) rotate(720deg);
            }
        }

        .success-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            padding: 24px 48px;
            border-radius: 16px;
            z-index: 1001;
            font-size: 1.5rem;
            font-weight: 500;
            text-align: center;
            box-shadow: var(--md-sys-elevation-level4);
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 600px) {
            .number-card {
                width: 70px;
                height: 100px;
                font-size: 1.75rem;
            }

            .operation {
                width: 48px;
                height: 48px;
                font-size: 1.25rem;
            }

            h1 {
                font-size: 1.75rem;
            }

            .controls {
                flex-wrap: wrap;
            }
        }

        /* æ— è®°å½•æç¤º */
        .empty-placeholder {
            text-align: center;
            padding: 16px;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.875rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>24ç‚¹æ¸¸æˆ</h1>
            <p class="game-description">ä½¿ç”¨å››ä¸ªæ•°å­—å’ŒåŸºæœ¬è¿ç®—ï¼ˆ+, -, Ã—, Ã·ï¼‰ï¼Œè®¡ç®—å‡ºç»“æœä¸º24ã€‚æ¯ä¸ªæ•°å­—å¿…é¡»ä¸”åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚</p>
        </header>

        <div class="md-card">
            <div class="game-status" id="game-status">
                <div class="game-status-text" id="game-status-text">è¯·é€‰æ‹©ç¬¬ä¸€ä¸ªæ•°</div>
                <div class="game-status-text">å‰©ä½™æ•°å­—: <span id="remaining-count">4</span>/4</div>
            </div>

            <div class="cards-container" id="cards-container">
                <!-- Cards will be generated here -->
            </div>

            <div class="operations">
                <button class="operation" data-op="+" id="op-add" disabled>+</button>
                <button class="operation" data-op="-" id="op-subtract" disabled>âˆ’</button>
                <button class="operation" data-op="*" id="op-multiply" disabled>Ã—</button>
                <button class="operation" data-op="/" id="op-divide" disabled>Ã·</button>
            </div>

            <div class="calculation-steps" id="calculation-steps">
                <!-- Calculation steps will be shown here -->
                <div class="empty-placeholder">è®¡ç®—æ­¥éª¤å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>
            </div>

            <div class="hint-container" id="hint-container">
                <div class="hint-title">æç¤º</div>
                <div class="hint-step" id="hint-step"></div>
            </div>

            <div class="controls">
                <button class="md-button md-button-outlined" id="undo-btn">æ’¤é”€</button>
                <button class="md-button md-button-filled" id="reset-btn">é‡ç½®</button>
                <button class="md-button md-button-tonal" id="new-game-btn">æ–°æ¸¸æˆ</button>
                <button class="md-button md-button-success" id="hint-btn">æç¤º</button>
                <button class="md-button md-button-text" id="verify-btn">éªŒè¯å¯è§£</button>
            </div>
        </div>

        <div class="md-card">
            <div class="md-card-title">æ¸¸æˆç»Ÿè®¡</div>

            <div class="level-indicator">
                <div class="level-name" id="level-name">æ–°æ‰‹</div>
                <div class="level-bar">
                    <div class="level-progress" id="level-progress" style="width: 0%"></div>
                </div>
                <div class="level-details">
                    <div id="current-level-info">ç­‰çº§ 1</div>
                    <div id="next-level-info">è¿˜éœ€ 5 æ¬¡æˆåŠŸ</div>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="success-count">0</div>
                    <div class="stat-label">æˆåŠŸè§£é¢˜</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="total-attempts">0</div>
                    <div class="stat-label">æ€»å°è¯•æ¬¡æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="success-rate">0%</div>
                    <div class="stat-label">æˆåŠŸç‡</div>
                </div>
            </div>

            <div class="history-title">æœ€è¿‘æ¸¸æˆ</div>
            <div id="history-list">
                <!-- History will be displayed here -->
                <div class="empty-placeholder">æš‚æ— æ¸¸æˆè®°å½•</div>
            </div>
        </div>
    </div>

    <button class="fab" id="help-btn">?</button>

    <div class="toast" id="toast"></div>
    <div class="success-message" id="success-message">æ­å–œï¼ä½ è§£å‡ºäº†24ç‚¹ï¼</div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Game state
            let gameState = {
                cards: [],                // åŸå§‹å¡ç‰‡å€¼
                usedCardIndexes: new Set(), // å·²ä½¿ç”¨çš„åŸå§‹å¡ç‰‡ç´¢å¼•
                currentStage: 1,          // 1: é€‰æ‹©ç¬¬ä¸€ä¸ªæ•°, 2: é€‰æ‹©è¿ç®—ç¬¦, 3: é€‰æ‹©ç¬¬äºŒä¸ªæ•°
                firstNumberIndex: null,   // ç¬¬ä¸€ä¸ªæ•°çš„ç´¢å¼•
                selectedOperator: null,   // é€‰æ‹©çš„è¿ç®—ç¬¦
                steps: [],                // è®¡ç®—æ­¥éª¤
                hintUsed: false,          // æ˜¯å¦ä½¿ç”¨äº†æç¤º
                originalCardCount: 4,     // åŸå§‹å¡ç‰‡æ•°é‡
                usedOriginalCards: 0      // å·²ä½¿ç”¨çš„åŸå§‹å¡ç‰‡æ•°é‡
            };

            // Game statistics
            let gameStats = loadGameStats();

            // Level definitions
            const levels = [
                { name: "æ–°æ‰‹", threshold: 0 },
                { name: "åˆå­¦è€…", threshold: 5 },
                { name: "è¿›é˜¶è€…", threshold: 15 },
                { name: "ç†Ÿç»ƒè€…", threshold: 30 },
                { name: "ä¸“å®¶", threshold: 50 },
                { name: "å¤§å¸ˆ", threshold: 75 },
                { name: "24ç‚¹ç‹è€…", threshold: 100 }
            ];

            // DOM elements
            const cardsContainer = document.getElementById('cards-container');
            const calculationSteps = document.getElementById('calculation-steps');
            const undoBtn = document.getElementById('undo-btn');
            const resetBtn = document.getElementById('reset-btn');
            const newGameBtn = document.getElementById('new-game-btn');
            const verifyBtn = document.getElementById('verify-btn');
            const addBtn = document.getElementById('op-add');
            const subtractBtn = document.getElementById('op-subtract');
            const multiplyBtn = document.getElementById('op-multiply');
            const divideBtn = document.getElementById('op-divide');
            const successMessage = document.getElementById('success-message');
            const remainingCount = document.getElementById('remaining-count');
            const gameStatusText = document.getElementById('game-status-text');
            const gameStatusContainer = document.getElementById('game-status');
            const successCountEl = document.getElementById('success-count');
            const totalAttemptsEl = document.getElementById('total-attempts');
            const successRateEl = document.getElementById('success-rate');
            const levelNameEl = document.getElementById('level-name');
            const levelProgressEl = document.getElementById('level-progress');
            const currentLevelInfoEl = document.getElementById('current-level-info');
            const nextLevelInfoEl = document.getElementById('next-level-info');
            const historyListEl = document.getElementById('history-list');
            const helpBtn = document.getElementById('help-btn');
            const toastEl = document.getElementById('toast');
            const hintBtn = document.getElementById('hint-btn');
            const hintContainer = document.getElementById('hint-container');
            const hintStep = document.getElementById('hint-step');

            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                // Generate cards until we find a solvable set
                let cards;
                let attempts = 0;
                do {
                    cards = generateRandomCards(4);
                    attempts++;
                } while (!isSolvable(cards) && attempts < 10);

                // If we couldn't find a solvable set after 10 attempts, use a known solvable set
                if (!isSolvable(cards)) {
                    cards = getKnownSolvableCards();
                }

                gameState.cards = cards;
                gameState.usedCardIndexes = new Set();
                gameState.currentStage = 1;
                gameState.firstNumberIndex = null;
                gameState.selectedOperator = null;
                gameState.steps = [];
                gameState.hintUsed = false;
                gameState.usedOriginalCards = 0;

                renderCards();
                renderCalculationSteps();
                updateGameState();
                updateGameStage();

                gameStatusContainer.classList.remove('success');
                hintContainer.style.display = 'none';

                remainingCount.textContent = gameState.originalCardCount - gameState.usedOriginalCards;
            }

            // ç”Ÿæˆéšæœºå¡ç‰‡
            function generateRandomCards(count) {
                const cards = [];
                for (let i = 0; i < count; i++) {
                    // éšæœºç”Ÿæˆ1-13ä¹‹é—´çš„æ•´æ•°
                    cards.push(Math.floor(Math.random() * 13) + 1);
                }
                return cards;
            }

            // è·å–å·²çŸ¥å¯è§£çš„å¡ç‰‡ç»„åˆ
            function getKnownSolvableCards() {
                const solvableSets = [
                    [3, 8, 3, 8],     // (3 + 8 + 3) * 8 = 24
                    [5, 5, 5, 1],      // 5 * 5 - 5 + 1 = 24
                    [4, 7, 8, 1],      // (7 - 4 - 1) * 8 = 24
                    [6, 3, 3, 2],      // 6 * 3 + 3 * 2 = 24
                    [9, 8, 3, 1],      // 9 * 8 / 3 = 24
                    [4, 6, 6, 1],      // (6 + 6) * 4 / 1 = 24
                    [10, 10, 4, 4],    // 10 + 10 + 4 = 24
                    [9, 7, 4, 4],      // 9 + 7 + 4 + 4 = 24
                    [12, 12, 6, 6]     // 12 * 6 / (12 / 6) = 24
                ];

                // éšæœºé€‰æ‹©ä¸€ä¸ªå¯è§£é›†åˆ
                return solvableSets[Math.floor(Math.random() * solvableSets.length)];
            }

            // æ£€æŸ¥å¡ç‰‡ç»„åˆæ˜¯å¦å¯è§£
            function isSolvable(cards) {
                // æ­¤å‡½æ•°ä½¿ç”¨ç©·ä¸¾æ³•æ£€æŸ¥ç»™å®šçš„å¡ç‰‡ç»„åˆæ˜¯å¦èƒ½å¾—åˆ°24
                if (!cards || cards.length !== 4) return false;

                // æ£€æŸ¥ç»“æœçš„å‡½æ•°
                function isCloseToTarget(value, target = 24, epsilon = 1e-6) {
                    return Math.abs(value - target) < epsilon;
                }

                // è·å–æ‰€æœ‰æ’åˆ—ç»„åˆ
                function getPermutations(arr) {
                    if (arr.length <= 1) return [arr];
                    const result = [];
                    for (let i = 0; i < arr.length; i++) {
                        const current = arr[i];
                        const remaining = [...arr.slice(0, i), ...arr.slice(i + 1)];
                        const perms = getPermutations(remaining);
                        for (const perm of perms) {
                            result.push([current, ...perm]);
                        }
                    }
                    return result;
                }

                // å°è¯•æ‰€æœ‰è¿ç®—ç¬¦ç»„åˆ
                const operations = ['+', '-', '*', '/'];
                const permutations = getPermutations(cards);

                // ä¸åŒçš„æ‹¬å·ä½ç½®æ¨¡å¼
                // æ— æ‹¬å·: a op1 b op2 c op3 d
                // æ¨¡å¼1: (a op1 b) op2 c op3 d
                // æ¨¡å¼2: a op1 (b op2 c) op3 d
                // æ¨¡å¼3: a op1 b op2 (c op3 d)
                // æ¨¡å¼4: (a op1 b) op2 (c op3 d)
                // æ¨¡å¼5: ((a op1 b) op2 c) op3 d
                // æ¨¡å¼6: (a op1 (b op2 c)) op3 d
                // æ¨¡å¼7: a op1 ((b op2 c) op3 d)
                // æ¨¡å¼8: a op1 (b op2 (c op3 d))

                for (const perm of permutations) {
                    for (const op1 of operations) {
                        for (const op2 of operations) {
                            for (const op3 of operations) {
                                const [a, b, c, d] = perm;

                                // è®¡ç®—æ‰€æœ‰å¯èƒ½çš„æ‹¬å·ç»„åˆ
                                try {
                                    // æ— æ‹¬å·
                                    let result = calculate(calculate(calculate(a, op1, b), op2, c), op3, d);
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼1: (a op1 b) op2 c op3 d
                                    result = calculate(calculate(calculate(a, op1, b), op2, c), op3, d);
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼2: a op1 (b op2 c) op3 d
                                    result = calculate(calculate(a, op1, calculate(b, op2, c)), op3, d);
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼3: a op1 b op2 (c op3 d)
                                    result = calculate(calculate(a, op1, b), op2, calculate(c, op3, d));
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼4: (a op1 b) op2 (c op3 d)
                                    result = calculate(calculate(a, op1, b), op2, calculate(c, op3, d));
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼5: ((a op1 b) op2 c) op3 d
                                    result = calculate(calculate(calculate(a, op1, b), op2, c), op3, d);
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼6: (a op1 (b op2 c)) op3 d
                                    result = calculate(calculate(a, op1, calculate(b, op2, c)), op3, d);
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼7: a op1 ((b op2 c) op3 d)
                                    result = calculate(a, op1, calculate(calculate(b, op2, c), op3, d));
                                    if (isCloseToTarget(result)) return true;

                                    // æ¨¡å¼8: a op1 (b op2 (c op3 d))
                                    result = calculate(a, op1, calculate(b, op2, calculate(c, op3, d)));
                                    if (isCloseToTarget(result)) return true;

                                } catch (e) {
                                    // å¯èƒ½å‡ºç°é™¤é›¶ç­‰é”™è¯¯ï¼Œç»§ç»­å°è¯•å…¶ä»–ç»„åˆ
                                    continue;
                                }
                            }
                        }
                    }
                }

                // å¦‚æœæ‰€æœ‰ç»„åˆéƒ½å°è¯•è¿‡äº†ï¼Œä»ç„¶æ²¡æœ‰è§£
                return false;
            }

            // æ‰§è¡Œå•ä¸ªè®¡ç®—
            function calculate(a, op, b) {
                switch (op) {
                    case '+': return a + b;
                    case '-': return a - b;
                    case '*': return a * b;
                    case '/':
                        if (b === 0) throw new Error("é™¤æ•°ä¸èƒ½ä¸º0");
                        if (a % b !== 0) throw new Error("é™¤æ³•ç»“æœå¿…é¡»æ˜¯æ•´æ•°");
                        return a / b;
                    default: throw new Error("æ— æ•ˆçš„è¿ç®—ç¬¦");
                }
            }

            // æ£€æŸ¥å½“å‰ç‰Œç»„æ˜¯å¦å¯è§£
            function verifyCurrentCards() {
                let remainingCards = [];
                for (let i = 0; i < gameState.cards.length; i++) {
                    if (!gameState.usedCardIndexes.has(i)) {
                        remainingCards.push(gameState.cards[i]);
                    }
                }

                // æ·»åŠ å·²æœ‰çš„ä¸­é—´ç»“æœ
                gameState.steps.forEach((step, index) => {
                    if (!step.used) {
                        remainingCards.push(step.result);
                    }
                });

                // æ ¹æ®å‰©ä½™å¡ç‰‡æ•°é‡å†³å®šéªŒè¯æ–¹å¼
                if (remainingCards.length === 1) {
                    // åªå‰©ä¸€å¼ å¡ç‰‡ï¼Œæ£€æŸ¥æ˜¯å¦ä¸º24
                    if (Math.abs(remainingCards[0] - 24) < 1e-6) {
                        showToast("å½“å‰ç»“æœä¸º24ï¼Œä½ å·²ç»æˆåŠŸäº†ï¼");
                    } else {
                        showToast("åªå‰©ä¸€å¼ å¡ç‰‡ä¸”ä¸ä¸º24ï¼Œè®¡ç®—æœ‰è¯¯ï¼Œè¯·é‡æ–°å°è¯•");
                        recordFailedAttempt("å•å¡é24");
                    }
                } else if (remainingCards.length > 1) {
                    // ä»æœ‰å¤šå¼ å¡ç‰‡ï¼Œæ£€æŸ¥å‰©ä½™å¡ç‰‡æ˜¯å¦å¯èƒ½å¾—åˆ°24
                    const combinations = [];

                    if (remainingCards.length === 2) {
                        // æµ‹è¯•ä¸¤å¼ å¡ç‰‡çš„æ‰€æœ‰å¯èƒ½è¿ç®—
                        const operations = ['+', '-', '*', '/'];
                        for (const op of operations) {
                            try {
                                const result = calculate(remainingCards[0], op, remainingCards[1]);
                                if (Math.abs(result - 24) < 1e-6) {
                                    combinations.push({
                                        cards: [remainingCards[0], remainingCards[1]],
                                        operations: [op],
                                        steps: [`${remainingCards[0]} ${getOperatorSymbol(op)} ${remainingCards[1]} = 24`]
                                    });
                                }
                            } catch (e) {
                                continue;
                            }

                            // æ£€æŸ¥åå‘è¿ç®—
                            try {
                                const result = calculate(remainingCards[1], op, remainingCards[0]);
                                if (Math.abs(result - 24) < 1e-6) {
                                    combinations.push({
                                        cards: [remainingCards[1], remainingCards[0]],
                                        operations: [op],
                                        steps: [`${remainingCards[1]} ${getOperatorSymbol(op)} ${remainingCards[0]} = 24`]
                                    });
                                }
                            } catch (e) {
                                continue;
                            }
                        }
                    } else {
                        // å¦‚æœæœ‰3å¼ æˆ–4å¼ å¡ç‰‡ï¼Œä½¿ç”¨é€’å½’æ–¹æ³•æŸ¥æ‰¾è§£
                        findSolutions(remainingCards, combinations);
                    }

                    if (combinations.length > 0) {
                        showToast("å½“å‰ç‰Œç»„æœ‰è§£ï¼Œç»§ç»­åŠªåŠ›ï¼");
                    } else {
                        showToast("å½“å‰ç‰Œç»„æ— è§£ï¼Œè¯·ç‚¹å‡»æ–°æ¸¸æˆé‡æ–°å¼€å§‹");
                    }
                }
            }

            // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„è§£å†³æ–¹æ¡ˆ
            function findSolutions(cards, solutions, currentOps = [], currentSteps = []) {
                // å¦‚æœåªå‰©ä¸€å¼ å¡ç‰‡ï¼Œæ£€æŸ¥æ˜¯å¦ä¸º24
                if (cards.length === 1) {
                    if (Math.abs(cards[0] - 24) < 1e-6) {
                        solutions.push({
                            cards: [...cards],
                            operations: [...currentOps],
                            steps: [...currentSteps]
                        });
                    }
                    return;
                }

                // å°è¯•æ‰€æœ‰å¯èƒ½çš„å¡ç‰‡å¯¹å’Œè¿ç®—ç¬¦
                for (let i = 0; i < cards.length; i++) {
                    for (let j = i + 1; j < cards.length; j++) {
                        const a = cards[i];
                        const b = cards[j];
                        const remainingCards = cards.filter((_, index) => index !== i && index !== j);

                        // å°è¯•æ‰€æœ‰è¿ç®—ç¬¦
                        for (const op of ['+', '-', '*', '/']) {
                            try {
                                // æ­£å‘è¿ç®—: a op b
                                const result = calculate(a, op, b);
                                const newCards = [...remainingCards, result];
                                const newOps = [...currentOps, op];
                                const newSteps = [...currentSteps, `${a} ${getOperatorSymbol(op)} ${b} = ${result}`];

                                findSolutions(newCards, solutions, newOps, newSteps);
                            } catch (e) {
                                // å¯èƒ½å‡ºç°é™¤é›¶ç­‰é”™è¯¯ï¼Œç»§ç»­å°è¯•å…¶ä»–ç»„åˆ
                            }

                            // å¦‚æœæ“ä½œä¸æ˜¯åŠ æ³•æˆ–ä¹˜æ³•(å®ƒä»¬æ˜¯å¯äº¤æ¢çš„)ï¼Œè¿˜è¦å°è¯•åå‘è¿ç®—
                            if (op === '-' || op === '/') {
                                try {
                                    // åå‘è¿ç®—: b op a
                                    const result = calculate(b, op, a);
                                    const newCards = [...remainingCards, result];
                                    const newOps = [...currentOps, op];
                                    const newSteps = [...currentSteps, `${b} ${getOperatorSymbol(op)} ${a} = ${result}`];

                                    findSolutions(newCards, solutions, newOps, newSteps);
                                } catch (e) {
                                    // å¯èƒ½å‡ºç°é™¤é›¶ç­‰é”™è¯¯ï¼Œç»§ç»­å°è¯•å…¶ä»–ç»„åˆ
                                }
                            }
                        }
                    }
                }
            }

            // æ›´æ–°æ¸¸æˆé˜¶æ®µUI
            function updateGameStage() {
                // è®¾ç½®è¿ç®—ç¬¦æŒ‰é’®å¯ç”¨æ€§
                [addBtn, subtractBtn, multiplyBtn, divideBtn].forEach(btn => {
                    btn.disabled = gameState.currentStage !== 2;
                });
            }

            // æ¸²æŸ“å¡ç‰‡
            function renderCards() {
                cardsContainer.innerHTML = '';

                // æ¸²æŸ“åŸå§‹å¡ç‰‡
                gameState.cards.forEach((card, index) => {
                    if (!gameState.usedCardIndexes.has(index)) {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'number-card';

                        // åœ¨é˜¶æ®µ1å’Œé˜¶æ®µ2éƒ½é«˜äº®æ˜¾ç¤ºé€‰ä¸­çš„å¡ç‰‡
                        if ((gameState.currentStage === 1 || gameState.currentStage === 2) && gameState.firstNumberIndex === index) {
                            cardElement.classList.add('selected');
                        }

                        if (gameState.currentStage === 3 && gameState.firstNumberIndex !== index) {
                            // ä¸ºç¬¬äºŒä¸ªé€‰æ‹©é«˜äº®å¯ç”¨å¡ç‰‡
                            cardElement.classList.add('available');
                        }

                        cardElement.textContent = card;
                        cardElement.addEventListener('click', () => selectCard(index));
                        cardsContainer.appendChild(cardElement);
                    }
                });

                // æ·»åŠ ä¸­é—´ç»“æœå¡ç‰‡
                gameState.steps.forEach((step, stepIndex) => {
                    if (!step.used) {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'number-card result-card';

                        // åœ¨é˜¶æ®µ1å’Œé˜¶æ®µ2éƒ½é«˜äº®æ˜¾ç¤ºé€‰ä¸­çš„å¡ç‰‡
                        if ((gameState.currentStage === 1 || gameState.currentStage === 2) && gameState.firstNumberIndex === 'result-' + stepIndex) {
                            cardElement.classList.add('selected');
                        }

                        if (gameState.currentStage === 3 && gameState.firstNumberIndex !== 'result-' + stepIndex) {
                            // ä¸ºç¬¬äºŒä¸ªé€‰æ‹©é«˜äº®å¯ç”¨å¡ç‰‡
                            cardElement.classList.add('available');
                        }

                        cardElement.textContent = step.result;
                        cardElement.addEventListener('click', () => selectResultCard(stepIndex));
                        cardsContainer.appendChild(cardElement);
                    }
                });

                remainingCount.textContent = gameState.originalCardCount - gameState.usedOriginalCards;

                // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€å¼ å¡ç‰‡ä¸”ä¸æ˜¯24
                checkForFailure();
            }

            // é€‰æ‹©å¡ç‰‡
            function selectCard(index) {
                if (gameState.usedCardIndexes.has(index)) return;

                if (gameState.currentStage === 1) {
                    // ç¬¬ä¸€ä¸ªæ•°å­—é€‰æ‹©
                    gameState.firstNumberIndex = index;
                    gameState.currentStage = 2;
                } else if (gameState.currentStage === 2) {
                    // å¦‚æœå¤„äºé€‰æ‹©è¿ç®—ç¬¦é˜¶æ®µä½†ç”¨æˆ·ç‚¹å‡»äº†å¦ä¸€å¼ å¡ç‰‡
                    // é‚£ä¹ˆå–æ¶ˆä¹‹å‰çš„é€‰æ‹©ï¼Œé€‰æ‹©æ–°çš„å¡ç‰‡
                    gameState.firstNumberIndex = index;
                    // ä¿æŒåœ¨é€‰æ‹©è¿ç®—ç¬¦é˜¶æ®µ
                } else if (gameState.currentStage === 3) {
                    // ç¬¬äºŒä¸ªæ•°å­—é€‰æ‹©
                    if (index === gameState.firstNumberIndex) return; // ä¸èƒ½é€‰æ‹©åŒä¸€å¼ å¡ç‰‡

                    // è·å–ä¸¤ä¸ªé€‰æ‹©çš„å€¼
                    const firstValue = (typeof gameState.firstNumberIndex === 'string' && gameState.firstNumberIndex.startsWith('result-'))
                        ? gameState.steps[parseInt(gameState.firstNumberIndex.split('-')[1])].result
                        : gameState.cards[gameState.firstNumberIndex];

                    const secondValue = gameState.cards[index];

                    // æ‰§è¡Œè®¡ç®—
                    performCalculation(firstValue, secondValue, gameState.firstNumberIndex, index);
                }

                renderCards();
                updateGameState();
                updateGameStage();
            }

            // é€‰æ‹©ç»“æœå¡ç‰‡
            function selectResultCard(stepIndex) {
                const cardId = 'result-' + stepIndex;

                if (gameState.steps[stepIndex].used) return;

                if (gameState.currentStage === 1) {
                    // ç¬¬ä¸€ä¸ªæ•°å­—é€‰æ‹©
                    gameState.firstNumberIndex = cardId;
                    gameState.currentStage = 2;
                } else if (gameState.currentStage === 2) {
                    // å¦‚æœå¤„äºé€‰æ‹©è¿ç®—ç¬¦é˜¶æ®µä½†ç”¨æˆ·ç‚¹å‡»äº†å¦ä¸€å¼ å¡ç‰‡
                    // é‚£ä¹ˆå–æ¶ˆä¹‹å‰çš„é€‰æ‹©ï¼Œé€‰æ‹©æ–°çš„å¡ç‰‡
                    gameState.firstNumberIndex = cardId;
                    // ä¿æŒåœ¨é€‰æ‹©è¿ç®—ç¬¦é˜¶æ®µ
                } else if (gameState.currentStage === 3) {
                    // ç¬¬äºŒä¸ªæ•°å­—é€‰æ‹©
                    if (cardId === gameState.firstNumberIndex) return; // ä¸èƒ½é€‰æ‹©åŒä¸€å¼ å¡ç‰‡

                    // è·å–ä¸¤ä¸ªé€‰æ‹©çš„å€¼
                    const firstValue = (typeof gameState.firstNumberIndex === 'string' && gameState.firstNumberIndex.startsWith('result-'))
                        ? gameState.steps[parseInt(gameState.firstNumberIndex.split('-')[1])].result
                        : gameState.cards[gameState.firstNumberIndex];

                    const secondValue = gameState.steps[stepIndex].result;

                    // æ‰§è¡Œè®¡ç®—
                    performCalculation(firstValue, secondValue, gameState.firstNumberIndex, cardId);
                }

                renderCards();
                updateGameState();
                updateGameStage();
            }

            // é€‰æ‹©è¿ç®—ç¬¦
            function selectOperator(operator) {
                if (gameState.currentStage !== 2) return;

                gameState.selectedOperator = operator;
                gameState.currentStage = 3;

                renderCards();
                updateGameState();
                updateGameStage();
            }

            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            function updateGameState() {
                if (gameState.currentStage === 1) {
                    gameStatusText.textContent = "è¯·é€‰æ‹©ç¬¬ä¸€ä¸ªæ•°";
                } else if (gameState.currentStage === 2) {
                    gameStatusText.textContent = "è¯·é€‰æ‹©è¿ç®—ç¬¦";
                } else if (gameState.currentStage === 3) {
                    gameStatusText.textContent = "è¯·é€‰æ‹©ç¬¬äºŒä¸ªæ•°";
                }
            }

            // æ‰§è¡Œè®¡ç®—
            function performCalculation(firstValue, secondValue, firstIndex, secondIndex) {
                let result;
                let operationText;

                // æ‰§è¡Œè®¡ç®—
                switch (gameState.selectedOperator) {
                    case '+':
                        result = firstValue + secondValue;
                        operationText = `${firstValue} + ${secondValue} = ${result}`;
                        break;
                    case '-':
                        result = firstValue - secondValue;
                        operationText = `${firstValue} âˆ’ ${secondValue} = ${result}`;
                        break;
                    case '*':
                        result = firstValue * secondValue;
                        operationText = `${firstValue} Ã— ${secondValue} = ${result}`;
                        break;
                    case '/':
                        // æ£€æŸ¥é™¤æ•°ä¸ºé›¶å’Œéæ•´æ•°ç»“æœ
                        if (secondValue === 0) {
                            showToast("é™¤æ•°ä¸èƒ½ä¸º0");
                            return;
                        }

                        if (firstValue % secondValue !== 0) {
                            showToast("é™¤æ³•ç»“æœå¿…é¡»æ˜¯æ•´æ•°");
                            return;
                        }

                        result = firstValue / secondValue;
                        operationText = `${firstValue} Ã· ${secondValue} = ${result}`;
                        break;
                }

                // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†åŸå§‹å¡ç‰‡
                let usedOriginalCardsInThisStep = 0;

                // åˆ¤æ–­ä½¿ç”¨çš„æ˜¯å¦æ˜¯åŸå§‹å¡ç‰‡
                if (typeof firstIndex === 'number') {
                    usedOriginalCardsInThisStep++;
                }

                if (typeof secondIndex === 'number') {
                    usedOriginalCardsInThisStep++;
                }

                // æ·»åŠ è®¡ç®—æ­¥éª¤
                gameState.steps.push({
                    firstValue,
                    secondValue,
                    operator: gameState.selectedOperator,
                    result,
                    text: operationText,
                    used: false,
                    firstIndex,
                    secondIndex,
                    usedOriginalCards: usedOriginalCardsInThisStep
                });

                // æ ‡è®°ä½¿ç”¨è¿‡çš„å¡ç‰‡
                if (typeof firstIndex === 'string' && firstIndex.startsWith('result-')) {
                    // æ ‡è®°ä½¿ç”¨è¿‡çš„ç»“æœ
                    const stepIndex = parseInt(firstIndex.split('-')[1]);
                    gameState.steps[stepIndex].used = true;
                } else {
                    // æ ‡è®°ä½¿ç”¨è¿‡çš„åŸå§‹å¡ç‰‡
                    gameState.usedCardIndexes.add(firstIndex);
                    gameState.usedOriginalCards++;
                }

                if (typeof secondIndex === 'string' && secondIndex.startsWith('result-')) {
                    // æ ‡è®°ä½¿ç”¨è¿‡çš„ç»“æœ
                    const stepIndex = parseInt(secondIndex.split('-')[1]);
                    gameState.steps[stepIndex].used = true;
                } else {
                    // æ ‡è®°ä½¿ç”¨è¿‡çš„åŸå§‹å¡ç‰‡
                    gameState.usedCardIndexes.add(secondIndex);
                    gameState.usedOriginalCards++;
                }

                // é‡ç½®é€‰æ‹©
                gameState.firstNumberIndex = null;
                gameState.selectedOperator = null;
                gameState.currentStage = 1;

                // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°24
                checkForSuccess(result);

                // æ›´æ–°UI
                renderCalculationSteps();
                renderCards();
                updateGameState();
                updateGameStage();
            }

            // æ¸²æŸ“è®¡ç®—æ­¥éª¤
            function renderCalculationSteps() {
                if (gameState.steps.length === 0) {
                    calculationSteps.innerHTML = '<div class="empty-placeholder">è®¡ç®—æ­¥éª¤å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>';
                    return;
                }

                calculationSteps.innerHTML = '';

                gameState.steps.forEach((step, index) => {
                    const stepElement = document.createElement('div');
                    stepElement.className = 'step';

                    const stepTextEl = document.createElement('div');
                    stepTextEl.className = 'step-text';
                    stepTextEl.textContent = step.text;

                    const stepStatusEl = document.createElement('div');
                    stepStatusEl.className = 'step-status';
                    stepStatusEl.textContent = step.used ? 'å·²ä½¿ç”¨' : 'å¯ç”¨';

                    stepElement.appendChild(stepTextEl);
                    stepElement.appendChild(stepStatusEl);

                    calculationSteps.appendChild(stepElement);
                });
            }

            // æ£€æŸ¥æ˜¯å¦æˆåŠŸ
            function checkForSuccess(result) {
                // åªæœ‰å½“æ‰€æœ‰åŸå§‹å¡ç‰‡éƒ½è¢«ä½¿ç”¨ä¸”ç»“æœä¸º24æ—¶æ‰ç®—æˆåŠŸ
                if (result === 24 && gameState.usedOriginalCards === gameState.originalCardCount) {
                    // æˆåŠŸï¼
                    gameStatusText.textContent = "æˆåŠŸï¼";
                    gameStatusContainer.classList.add('success');

                    // æ›´æ–°ç»Ÿè®¡æ•°æ®
                    gameStats.totalSuccess++;
                    gameStats.totalAttempts++;
                    gameStats.recentGames.unshift({
                        success: true,
                        steps: [...gameState.steps.map(step => ({ ...step }))],
                        date: new Date().toISOString(),
                        cards: [...gameState.cards],
                        hintUsed: gameState.hintUsed
                    });

                    // é™åˆ¶æœ€è¿‘æ¸¸æˆè®°å½•æ•°é‡
                    if (gameStats.recentGames.length > 10) {
                        gameStats.recentGames.pop();
                    }

                    saveGameStats();
                    updateStatsDisplay();

                    // åº†ç¥
                    celebrateSuccess();
                }
            }

            // æ£€æŸ¥æ˜¯å¦å¤±è´¥(åªå‰©ä¸€å¼ å¡ä¸”ä¸æ˜¯24)
            function checkForFailure() {
                const availableCards = gameState.cards.filter((_, index) => !gameState.usedCardIndexes.has(index));
                const availableResults = gameState.steps.filter(step => !step.used);

                // å¦‚æœåªå‰©ä¸€å¼ å¡ç‰‡(æ— è®ºæ˜¯åŸå§‹å¡ç‰‡è¿˜æ˜¯ç»“æœå¡ç‰‡)
                if (availableCards.length + availableResults.length === 1) {
                    let lastCardValue;

                    if (availableCards.length === 1) {
                        lastCardValue = availableCards[0];
                    } else if (availableResults.length === 1) {
                        lastCardValue = availableResults[0].result;
                    }

                    // æ£€æŸ¥æœ€åä¸€å¼ å¡æ˜¯å¦ä¸º24
                    if (Math.abs(lastCardValue - 24) >= 1e-6) {
                        // å¤±è´¥ï¼æœ€åä¸€å¼ å¡ä¸æ˜¯24
                        gameStatusText.textContent = "å¤±è´¥ï¼æœ€åä¸€å¼ å¡ä¸æ˜¯24";
                        recordFailedAttempt("å•å¡é24");
                    }
                }
            }

            // è®°å½•å¤±è´¥å°è¯•
            function recordFailedAttempt(reason) {
                // å¦‚æœæ¸¸æˆå·²æˆåŠŸï¼Œä¸è®°å½•å¤±è´¥
                if (gameStatusContainer.classList.contains('success')) {
                    return;
                }

                gameStats.totalAttempts++;
                gameStats.recentGames.unshift({
                    success: false,
                    steps: [...gameState.steps.map(step => ({ ...step }))],
                    date: new Date().toISOString(),
                    cards: [...gameState.cards],
                    hintUsed: gameState.hintUsed,
                    failReason: reason
                });

                // é™åˆ¶æœ€è¿‘æ¸¸æˆè®°å½•æ•°é‡
                if (gameStats.recentGames.length > 10) {
                    gameStats.recentGames.pop();
                }

                saveGameStats();
                updateStatsDisplay();
            }

            // æ’¤é”€ä¸Šä¸€æ­¥
            function undoLastStep() {
                if (gameState.steps.length === 0) {
                    // å¦‚æœæ²¡æœ‰æ­¥éª¤ï¼Œé‡ç½®é€‰æ‹©çŠ¶æ€
                    gameState.firstNumberIndex = null;
                    gameState.selectedOperator = null;
                    gameState.currentStage = 1;
                    renderCards();
                    updateGameState();
                    updateGameStage();
                    return;
                }

                // è·å–æœ€åä¸€æ­¥æ“ä½œ
                const lastStep = gameState.steps.pop();

                // æ¢å¤ä½¿ç”¨çš„å¡ç‰‡
                if (typeof lastStep.firstIndex === 'string' && lastStep.firstIndex.startsWith('result-')) {
                    // æ¢å¤ä½¿ç”¨çš„ç»“æœå¡ç‰‡
                    const stepIndex = parseInt(lastStep.firstIndex.split('-')[1]);
                    if (stepIndex >= 0 && stepIndex < gameState.steps.length) {
                        gameState.steps[stepIndex].used = false;
                    }
                } else if (typeof lastStep.firstIndex === 'number') {
                    // æ¢å¤ä½¿ç”¨çš„åŸå§‹å¡ç‰‡
                    gameState.usedCardIndexes.delete(lastStep.firstIndex);
                    gameState.usedOriginalCards--;
                }

                if (typeof lastStep.secondIndex === 'string' && lastStep.secondIndex.startsWith('result-')) {
                    // æ¢å¤ä½¿ç”¨çš„ç»“æœå¡ç‰‡
                    const stepIndex = parseInt(lastStep.secondIndex.split('-')[1]);
                    if (stepIndex >= 0 && stepIndex < gameState.steps.length) {
                        gameState.steps[stepIndex].used = false;
                    }
                } else if (typeof lastStep.secondIndex === 'number') {
                    // æ¢å¤ä½¿ç”¨çš„åŸå§‹å¡ç‰‡
                    gameState.usedCardIndexes.delete(lastStep.secondIndex);
                    gameState.usedOriginalCards--;
                }

                // é‡ç½®é€‰æ‹©çŠ¶æ€
                gameState.firstNumberIndex = null;
                gameState.selectedOperator = null;
                gameState.currentStage = 1;

                // æ›´æ–°UI
                renderCalculationSteps();
                renderCards();
                updateGameState();
                updateGameStage();
                gameStatusContainer.classList.remove('success');

                remainingCount.textContent = gameState.originalCardCount - gameState.usedOriginalCards;
            }

            // é‡ç½®æ¸¸æˆ
            function resetGame() {
                gameState.usedCardIndexes = new Set();
                gameState.steps = [];
                gameState.firstNumberIndex = null;
                gameState.selectedOperator = null;
                gameState.currentStage = 1;
                gameState.hintUsed = false;
                gameState.usedOriginalCards = 0;

                renderCards();
                renderCalculationSteps();
                updateGameState();
                updateGameStage();
                gameStatusContainer.classList.remove('success');
                hintContainer.style.display = 'none';

                remainingCount.textContent = gameState.originalCardCount - gameState.usedOriginalCards;
            }

            // æ›´æ–°ç»Ÿè®¡æ˜¾ç¤º
            function updateStatsDisplay() {
                successCountEl.textContent = gameStats.totalSuccess;
                totalAttemptsEl.textContent = gameStats.totalAttempts;

                const rate = gameStats.totalAttempts > 0
                    ? Math.round((gameStats.totalSuccess / gameStats.totalAttempts) * 100)
                    : 0;
                successRateEl.textContent = rate + '%';

                // æ›´æ–°ç­‰çº§ä¿¡æ¯
                let currentLevel = 0;
                let nextLevelThreshold = 0;

                // æ‰¾åˆ°å½“å‰ç­‰çº§
                for (let i = levels.length - 1; i >= 0; i--) {
                    if (gameStats.totalSuccess >= levels[i].threshold) {
                        currentLevel = i;
                        levelNameEl.textContent = levels[i].name;
                        break;
                    }
                }

                // è·å–ä¸‹ä¸€çº§é˜ˆå€¼
                if (currentLevel < levels.length - 1) {
                    nextLevelThreshold = levels[currentLevel + 1].threshold;
                    nextLevelInfoEl.textContent = `è¿˜éœ€ ${nextLevelThreshold - gameStats.totalSuccess} æ¬¡æˆåŠŸ`;
                } else {
                    nextLevelInfoEl.textContent = 'å·²è¾¾åˆ°æœ€é«˜ç­‰çº§';
                }

                // æ›´æ–°è¿›åº¦æ¡
                if (currentLevel < levels.length - 1) {
                    const currentThreshold = levels[currentLevel].threshold;
                    const nextThreshold = levels[currentLevel + 1].threshold;
                    const progress = ((gameStats.totalSuccess - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
                    levelProgressEl.style.width = progress + '%';
                } else {
                    levelProgressEl.style.width = '100%';
                }

                currentLevelInfoEl.textContent = `ç­‰çº§ ${currentLevel + 1}`;

                // æ›´æ–°æœ€è¿‘æ¸¸æˆ
                renderHistory();
            }

            // æ¸²æŸ“å†å²è®°å½•
            function renderHistory() {
                historyListEl.innerHTML = '';

                if (gameStats.recentGames.length === 0) {
                    historyListEl.innerHTML = '<div class="empty-placeholder">æš‚æ— æ¸¸æˆè®°å½•</div>';
                    return;
                }

                gameStats.recentGames.forEach((game, index) => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';

                    const dateSpan = document.createElement('div');
                    const date = new Date(game.date);
                    const formattedDate = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
                    dateSpan.textContent = formattedDate;

                    const cardsSpan = document.createElement('div');
                    if (game.cards && game.cards.length > 0) {
                        cardsSpan.textContent = game.cards.join(', ');
                    }

                    const resultSpan = document.createElement('div');
                    resultSpan.className = game.success ? 'history-result history-success' : 'history-result history-fail';
                    resultSpan.textContent = game.success ? 'æˆåŠŸ' : 'å¤±è´¥';

                    // æ˜¾ç¤ºæ˜¯å¦ä½¿ç”¨äº†æç¤º
                    if (game.hintUsed) {
                        resultSpan.textContent += ' (æç¤º)';
                    }

                    historyItem.appendChild(dateSpan);
                    historyItem.appendChild(cardsSpan);
                    historyItem.appendChild(resultSpan);

                    historyListEl.appendChild(historyItem);
                });
            }

            // ä» localStorage åŠ è½½æ¸¸æˆç»Ÿè®¡
            function loadGameStats() {
                try {
                    const statsData = localStorage.getItem('24game_stats');
                    return statsData ? JSON.parse(statsData) : {
                        totalSuccess: 0,
                        totalAttempts: 0,
                        recentGames: []
                    };
                } catch (e) {
                    return {
                        totalSuccess: 0,
                        totalAttempts: 0,
                        recentGames: []
                    };
                }
            }

            // ä¿å­˜æ¸¸æˆç»Ÿè®¡åˆ° localStorage
            function saveGameStats() {
                try {
                    localStorage.setItem('24game_stats', JSON.stringify(gameStats));
                } catch (e) {
                    console.error('Failed to save game stats', e);
                }
            }

            // åº†ç¥æˆåŠŸ
            function celebrateSuccess() {
                // åˆ›å»ºäº”å½©çº¸å±‘
                for (let i = 0; i < 100; i++) {
                    createConfetti();
                }

                // æ˜¾ç¤ºæˆåŠŸä¿¡æ¯
                successMessage.style.display = 'block';
                setTimeout(() => {
                    successMessage.style.display = 'none';
                }, 3000);
            }

            // åˆ›å»ºäº”å½©çº¸å±‘
            function createConfetti() {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';

                // éšæœºä½ç½®ã€é¢œè‰²å’Œå¤§å°
                const colors = ['#6750A4', '#7D5260', '#625B71', '#B3261E', '#388E3C', '#0288D1', '#FF9800', '#E91E63', '#00BCD4'];
                const randomColor = colors[Math.floor(Math.random() * colors.length)];

                // éšæœºé€‰æ‹©å½¢çŠ¶ï¼šå½©å¸¦æˆ–åœ†å½¢
                const isRibbon = Math.random() > 0.3;

                if (isRibbon) {
                    // å½©å¸¦å½¢çŠ¶
                    const randomWidth = Math.floor(Math.random() * 8) + 3;
                    const randomHeight = Math.floor(Math.random() * 15) + 10;
                    confetti.style.width = `${randomWidth}px`;
                    confetti.style.height = `${randomHeight}px`;
                    confetti.style.backgroundColor = randomColor;
                    // ä¸ç›´æ¥è®¾ç½®transformï¼Œè€Œæ˜¯æ·»åŠ ä¸€ä¸ªç±»
                    confetti.classList.add('ribbon');
                } else {
                    // åœ†å½¢çº¸å±‘
                    const randomSize = Math.floor(Math.random() * 8) + 4;
                    confetti.style.width = `${randomSize}px`;
                    confetti.style.height = `${randomSize}px`;
                    confetti.style.backgroundColor = randomColor;
                    confetti.style.borderRadius = '50%';
                }

                const randomLeft = Math.floor(Math.random() * window.innerWidth);
                const randomDelay = Math.random() * 2; // å‡å°‘æœ€å¤§å»¶è¿Ÿ
                const randomDuration = 2 + Math.random() * 3; // è°ƒæ•´åŠ¨ç”»æ—¶é•¿

                confetti.style.left = `${randomLeft}px`;
                confetti.style.top = '-20px';
                confetti.style.animationDelay = `${randomDelay}s`;
                confetti.style.animationDuration = `${randomDuration}s`;

                // æ·»åŠ é¢å¤–çš„æ—‹è½¬æ ·å¼ï¼Œä¸è¦†ç›–åŸºæœ¬åŠ¨ç”»
                if (isRibbon) {
                    // ç»™å½©å¸¦æ·»åŠ éšæœºå€¾æ–œè§’åº¦ï¼Œä½†ä¸ä½¿ç”¨transformå±æ€§
                    confetti.style.rotate = `${Math.random() * 360}deg`;
                }

                document.body.appendChild(confetti);

                // æ›´é•¿çš„è¶…æ—¶æ—¶é—´ç¡®ä¿åŠ¨ç”»å®Œå…¨ç»“æŸ
                setTimeout(() => {
                    confetti.remove();
                }, (randomDuration + randomDelay) * 1000 + 1000); // é¢å¤–å¢åŠ 1ç§’
            }

            // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
            function showToast(message) {
                toastEl.textContent = message;
                toastEl.classList.add('show');

                setTimeout(() => {
                    toastEl.classList.remove('show');
                }, 3000);
            }

            // æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
            function showHelp() {
                showToast("é€‰æ‹©ä¸€ä¸ªæ•°ï¼Œç„¶åé€‰æ‹©ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œå†é€‰æ‹©å¦ä¸€ä¸ªæ•°ã€‚æ‰€æœ‰å››ä¸ªæ•°å­—éƒ½å¿…é¡»ä½¿ç”¨ï¼Œä¸”æœ€ç»ˆç»“æœä¸º24æ‰ç®—æˆåŠŸï¼");
            }

            // è·å–æç¤º
            function getHint() {
                // æ ‡è®°å·²ä½¿ç”¨æç¤º
                if (!gameState.hintUsed) {
                    gameState.hintUsed = true;

                    // è®°å½•ä½¿ç”¨æç¤ºä¸ºå¤±è´¥å°è¯•
                    recordFailedAttempt("ä½¿ç”¨æç¤º");
                }

                // è·å–å¯ç”¨æ•°å­—
                let availableNumbers = [];

                // æ·»åŠ æœªä½¿ç”¨çš„åŸå§‹å¡ç‰‡
                for (let i = 0; i < gameState.cards.length; i++) {
                    if (!gameState.usedCardIndexes.has(i)) {
                        availableNumbers.push({
                            value: gameState.cards[i],
                            index: i,
                            type: 'original'
                        });
                    }
                }

                // æ·»åŠ ä¸­é—´ç»“æœ
                gameState.steps.forEach((step, index) => {
                    if (!step.used) {
                        availableNumbers.push({
                            value: step.result,
                            index: index,
                            type: 'result'
                        });
                    }
                });

                // æ ¹æ®å‰©ä½™å¡ç‰‡æ‰¾å‡ºå®Œæ•´è§£æ³•
                const solutions = [];
                findCompleteSolutions(availableNumbers, solutions);

                if (solutions.length > 0) {
                    // é€‰æ‹©æœ€çŸ­çš„è§£æ³•
                    solutions.sort((a, b) => a.steps.length - b.steps.length);
                    const bestSolution = solutions[0];

                    // ç”Ÿæˆå®Œæ•´æç¤ºHTML
                    let hintHTML = '<div style="font-weight: bold; margin-bottom: 8px;">å®Œæ•´è§£é¢˜æ­¥éª¤:</div>';
                    bestSolution.steps.forEach((step, index) => {
                        hintHTML += `<div style="margin-bottom: 4px;">æ­¥éª¤ ${index + 1}: ${step}</div>`;
                    });

                    hintStep.innerHTML = hintHTML;
                    hintContainer.style.display = 'block';
                } else {
                    showToast("æ— æ³•æ‰¾åˆ°æœ‰æ•ˆæç¤º");
                }
            }

            // æ‰¾åˆ°å®Œæ•´è§£å†³æ–¹æ¡ˆ
            function findCompleteSolutions(availableCards, solutions) {
                // è½¬æ¢å¡ç‰‡æ ¼å¼ä¸ºçº¯æ•°å€¼æ•°ç»„
                const cards = availableCards.map(card => card.value);

                // è·å–æ‰€æœ‰å¡ç‰‡çš„æ’åˆ—ç»„åˆ
                const permutations = getPermutations(cards);
                const operations = ['+', '-', '*', '/'];

                // ä¸åŒçš„æ‹¬å·ä½ç½®æ¨¡å¼æ¥æµ‹è¯•
                const patterns = [
                    // ((a op1 b) op2 c) op3 d
                    (a, b, c, d, op1, op2, op3) => {
                        try {
                            const step1 = calculate(a, op1, b);
                            const step2 = calculate(step1, op2, c);
                            const result = calculate(step2, op3, d);
                            if (Math.abs(result - 24) < 1e-6) {
                                return [
                                    `${a} ${getOperatorSymbol(op1)} ${b} = ${step1}`,
                                    `${step1} ${getOperatorSymbol(op2)} ${c} = ${step2}`,
                                    `${step2} ${getOperatorSymbol(op3)} ${d} = 24`
                                ];
                            }
                        } catch (e) { }
                        return null;
                    },

                    // (a op1 (b op2 c)) op3 d
                    (a, b, c, d, op1, op2, op3) => {
                        try {
                            const step1 = calculate(b, op2, c);
                            const step2 = calculate(a, op1, step1);
                            const result = calculate(step2, op3, d);
                            if (Math.abs(result - 24) < 1e-6) {
                                return [
                                    `${b} ${getOperatorSymbol(op2)} ${c} = ${step1}`,
                                    `${a} ${getOperatorSymbol(op1)} ${step1} = ${step2}`,
                                    `${step2} ${getOperatorSymbol(op3)} ${d} = 24`
                                ];
                            }
                        } catch (e) { }
                        return null;
                    },

                    // a op1 ((b op2 c) op3 d)
                    (a, b, c, d, op1, op2, op3) => {
                        try {
                            const step1 = calculate(b, op2, c);
                            const step2 = calculate(step1, op3, d);
                            const result = calculate(a, op1, step2);
                            if (Math.abs(result - 24) < 1e-6) {
                                return [
                                    `${b} ${getOperatorSymbol(op2)} ${c} = ${step1}`,
                                    `${step1} ${getOperatorSymbol(op3)} ${d} = ${step2}`,
                                    `${a} ${getOperatorSymbol(op1)} ${step2} = 24`
                                ];
                            }
                        } catch (e) { }
                        return null;
                    },

                    // a op1 (b op2 (c op3 d))
                    (a, b, c, d, op1, op2, op3) => {
                        try {
                            const step1 = calculate(c, op3, d);
                            const step2 = calculate(b, op2, step1);
                            const result = calculate(a, op1, step2);
                            if (Math.abs(result - 24) < 1e-6) {
                                return [
                                    `${c} ${getOperatorSymbol(op3)} ${d} = ${step1}`,
                                    `${b} ${getOperatorSymbol(op2)} ${step1} = ${step2}`,
                                    `${a} ${getOperatorSymbol(op1)} ${step2} = 24`
                                ];
                            }
                        } catch (e) { }
                        return null;
                    },

                    // (a op1 b) op2 (c op3 d)
                    (a, b, c, d, op1, op2, op3) => {
                        try {
                            const step1 = calculate(a, op1, b);
                            const step2 = calculate(c, op3, d);
                            const result = calculate(step1, op2, step2);
                            if (Math.abs(result - 24) < 1e-6) {
                                return [
                                    `${a} ${getOperatorSymbol(op1)} ${b} = ${step1}`,
                                    `${c} ${getOperatorSymbol(op3)} ${d} = ${step2}`,
                                    `${step1} ${getOperatorSymbol(op2)} ${step2} = 24`
                                ];
                            }
                        } catch (e) { }
                        return null;
                    }
                ];

                // å°è¯•æ‰€æœ‰å¯èƒ½çš„æ’åˆ—å’Œæ“ä½œ
                for (const perm of permutations) {
                    for (const op1 of operations) {
                        for (const op2 of operations) {
                            for (const op3 of operations) {
                                for (const pattern of patterns) {
                                    const steps = pattern(perm[0], perm[1], perm[2], perm[3], op1, op2, op3);
                                    if (steps) {
                                        solutions.push({
                                            cards: perm,
                                            steps: steps
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                return solutions;
            }

            // è·å–æ‰€æœ‰æ’åˆ—ç»„åˆ
            function getPermutations(arr) {
                if (arr.length <= 1) return [arr];
                const result = [];
                for (let i = 0; i < arr.length; i++) {
                    const current = arr[i];
                    const remaining = [...arr.slice(0, i), ...arr.slice(i + 1)];
                    const perms = getPermutations(remaining);
                    for (const perm of perms) {
                        result.push([current, ...perm]);
                    }
                }
                return result;
            }

            // è·å–è¿ç®—ç¬¦ç¬¦å·
            function getOperatorSymbol(op) {
                switch (op) {
                    case '+': return '+';
                    case '-': return 'âˆ’';
                    case '*': return 'Ã—';
                    case '/': return 'Ã·';
                    default: return op;
                }
            }

            // åˆå§‹åŒ–æ¸¸æˆ
            initGame();
            updateStatsDisplay();

            // äº‹ä»¶ç›‘å¬
            undoBtn.addEventListener('click', undoLastStep);
            resetBtn.addEventListener('click', resetGame);
            verifyBtn.addEventListener('click', verifyCurrentCards);
            newGameBtn.addEventListener('click', () => {
                // å¦‚æœæœ‰æ­¥éª¤ä½†æœªæˆåŠŸï¼Œè®°å½•å¤±è´¥å°è¯•
                if (gameState.steps.length > 0 && !gameStatusContainer.classList.contains('success')) {
                    gameStats.totalAttempts++;
                    gameStats.recentGames.unshift({
                        success: false,
                        steps: [...gameState.steps.map(step => ({ ...step }))],
                        date: new Date().toISOString(),
                        cards: [...gameState.cards],
                        hintUsed: gameState.hintUsed,
                        failReason: "æ”¾å¼ƒ"
                    });

                    // é™åˆ¶æœ€è¿‘æ¸¸æˆè®°å½•æ•°é‡
                    if (gameStats.recentGames.length > 10) {
                        gameStats.recentGames.pop();
                    }

                    saveGameStats();
                    updateStatsDisplay();
                }

                initGame();
            });

            addBtn.addEventListener('click', () => selectOperator('+'));
            subtractBtn.addEventListener('click', () => selectOperator('-'));
            multiplyBtn.addEventListener('click', () => selectOperator('*'));
            divideBtn.addEventListener('click', () => selectOperator('/'));

            helpBtn.addEventListener('click', showHelp);
            hintBtn.addEventListener('click', getHint);
        });
    </script>
</body>

</html>
